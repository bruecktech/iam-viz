<html>
<head>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.8.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.8.0/vis.min.css" rel="stylesheet" type="text/css" />

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 100%;
            border: 1px solid lightgray;
        }
    </style>
    <script src="graph.js"></script>
</head>
<body>
  <div id="mynetwork"></div>
  <script type="text/javascript">
    var allNodes;
    var network;
    var nodesDataSet;
    var edgesDataSet;
    var highlightActive = false;

    function httpGet(theUrl)
    {
      var xmlHttp = new XMLHttpRequest();
      xmlHttp.open( "GET", theUrl, false ); // false for synchronous request
      xmlHttp.send( null );
      return xmlHttp.responseText;
    }

    function redrawAll(){
      // provide data in the DOT language
      //var DOTstring = 'dinetwork {1 -> 1 -> 2; 2 -> 3; 2 -- 4; 2 -> 1 }';

      //var DOTstring = httpGet("/graph.dot");
      //var parsedData = vis.network.convertDot(DOTstring);

      var options = {
        nodes: {
          shape: 'dot',
          color: 'blue',
          scaling: {
            min: 10,
            max: 30,
	    label: {
              min: 8,
              max: 30,
              drawThreshold: 12,
              maxVisible: 20
            }
          },
          font: {
            size: 12,
            face: 'Tahoma'
          }
        },
	edges: {
	  color: {inherit: 'from'}
	}
      };

      // get a JSON object
      //edgesDataset = new vis.DataSet(parsedData.edges);
      //nodesDataset = new vis.DataSet(parsedData.nodes);
      edgesDataset = new vis.DataSet(edges);
      nodesDataset = new vis.DataSet(nodes);
      allNodes = nodesDataset.get({returnType:"Object"});

      // create a network
      var container = document.getElementById('mynetwork');
      var data = {nodes: nodesDataset, edges: edgesDataset};
      network = new vis.Network(container, data, options);
      //network.setOptions({layout: {hierarchical:{ enabled:true } }});
      //network.focus(1,{scale: 1, offset:{x: -(width/3)}});

      network.on("click",neighbourhoodHighlight);
    }

    function neighbourhoodHighlight(params) {
      console.log(params);
      // if something is selected:
      if (params.nodes.length > 0) {
        highlightActive = true;
        var i,j;
        var selectedNode = params.nodes[0];
        var degrees = 2;

        // mark all nodes as hard to read.
        for (var nodeId in allNodes) {
          allNodes[nodeId].color = 'rgba(200,200,200,0.5)';
          if (allNodes[nodeId].hiddenLabel === undefined) {
            allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
            allNodes[nodeId].label = undefined;
          }
        }
        var connectedNodes = network.getConnectedNodes(selectedNode);
        var allConnectedNodes = [];

        // get the second degree nodes
        for (i = 1; i < degrees; i++) {
          for (j = 0; j < connectedNodes.length; j++) {
            allConnectedNodes = allConnectedNodes.concat(network.getConnectedNodes(connectedNodes[j]));
          }
        }

        // all second degree nodes get a different color and their label back
        for (i = 0; i < allConnectedNodes.length; i++) {
          allNodes[allConnectedNodes[i]].color = 'rgba(150,150,150,0.75)';
          if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
            allNodes[allConnectedNodes[i]].label = allNodes[allConnectedNodes[i]].hiddenLabel;
            allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
          }
        }

        // all first degree nodes get their own color and their label back
        for (i = 0; i < connectedNodes.length; i++) {
          allNodes[connectedNodes[i]].color = undefined;
          if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
            allNodes[connectedNodes[i]].label = allNodes[connectedNodes[i]].hiddenLabel;
            allNodes[connectedNodes[i]].hiddenLabel = undefined;
          }
        }

        // the main node gets its own color and its label back.
        allNodes[selectedNode].color = undefined;
        if (allNodes[selectedNode].hiddenLabel !== undefined) {
          allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
          allNodes[selectedNode].hiddenLabel = undefined;
        }
      }
      else if (highlightActive === true) {
        // reset all nodes
        for (var nodeId in allNodes) {
          allNodes[nodeId].color = undefined;
          if (allNodes[nodeId].hiddenLabel !== undefined) {
            allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
            allNodes[nodeId].hiddenLabel = undefined;
          }
        }
        highlightActive = false
      }

      // transform the object into an array
      var updateArray = [];
      for (nodeId in allNodes) {
        if (allNodes.hasOwnProperty(nodeId)) {
          updateArray.push(allNodes[nodeId]);
        }
      }
      nodesDataset.update(updateArray);
    }

    /**
    function handleFileSelect(evt) {
      var files = evt.target.files; // FileList object

      // Loop through the FileList
      for (var i = 0, f; f = files[i]; i++) {

      var reader = new FileReader();

      // Closure to capture the file information.
      reader.onload = (function(theFile) {
          return function(e) {
              drawGraph(e.target.result);
          };
      })(f);

      // Read in the file
      //reader.readAsDataText(f,UTF-8);
      //reader.readAsDataURL(f);

      reader.readAsText(f);
      }
    }
    document.getElementById('files').addEventListener('change', handleFileSelect, false);
    **/
    redrawAll();
    </script>
</body>
</html>
